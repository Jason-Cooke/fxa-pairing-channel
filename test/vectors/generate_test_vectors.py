#
# This is a script to generate a static "trace" of a TLS1.3 handshake
# using the known-good implementation from `tlslite-ng`.  We use the
# components of the trace as test vectors for the JS implementation.
#
# You'll need to install tlslite-ng from this fork, which includes a couple
# of cleanups for running in PSK-only mode:
#
#    https://github.com/rfk/tlslite-ng/compare/master...rfk:tls13-psk-only?expand=1
#
# Then run this script like so:
#
#    pip install tlslite-ng
#    python ./generate_test_vectors.py > test_vectors.js
#

import os
import queue
import threading
import collections
from binascii import hexlify

from tlslite.api import TLSConnection, HandshakeSettings
from tlslite.utils.cryptomath import secureHash, secureHMAC, derive_secret
from tlslite.handshakehashes import HandshakeHashes

# This script basically prints out a JS file declaring a big Object with
# one property per useful chunk of test vector.  Here's the file header.

print("""//
// This file was auto-generated by `./generate_test_vectors.py`
//

/* eslint-disable sorting/sort-object-props */
/* exported TEST_VECTORS */

const TEST_VECTORS = {
""")

# And here are some helper functions for printing out
# individual chunks of bytes with a nice name.

def printTestVectorBytes(name, bytes):
    # Print it out as hexlified data in chunks of 40 bytes,
    # so that the final file is nice and readable.
    print("  {}: hexToBytes(".format(name))
    while len(bytes) > 40:
        print("    '" + hexlify(bytes[:40]).decode("ascii") + "' +")
        bytes = bytes[40:]
    print("    '" + hexlify(bytes).decode("ascii") + "'")
    print("  ),")


def printTestVectorStr(name, bytes):
    print("  {}: utf8ToBytes('{}'),".format(name, bytes.decode('ascii')))


def printComment(comment):
    print("  // {}".format(comment))


# Mock out os.urandom so that we can generate stable test vectors.

MOCKED_URANDOM_CALLS = collections.deque()

def mock_urandom(size):
    try:
        mocked_value = MOCKED_URANDOM_CALLS.popleft()
    except IndexError:
        raise AssertionError('unmocked call to os.urandom({})'.format(size))
    if size != len(mocked_value):
        raise AssertionError('unexpected call to os.urandom({})'.format(size))
    return mocked_value

orig_urandom = os.urandom
os.urandom = mock_urandom

# These are some helpers for capturing the data sent out to the "socket"
# by tlslite-ng. Hooray for duck-typing!

class Mocket:
    """A mock socket, that captures the data it's asked to send."""

    def __init__(self, send_queue, recv_queue):
        self.sent_data = []
        self._send_queue = send_queue
        self._recv_queue = recv_queue
        self._buffer = b''
        self._closed = False

    def close(self):
        self._send_queue.put(None)

    def send(self, bytes):
        self.sent_data.append(bytes)
        self._send_queue.put(bytes)
        return len(bytes)

    def sendall(self, bytes):
        self.send(bytes)

    def recv(self, bufsize):
        if self._closed:
            return b''
        while len(self._buffer) < bufsize:
            bytes = self._recv_queue.get(timeout=5)
            if bytes is None:
                self._closed = True
                break
            self._buffer += bytes
        bytes = self._buffer[:bufsize]
        self._buffer = self._buffer[len(bytes):]
        return bytes


def mocketpair():
    """Make a pair of Mockets that are connected to each other."""
    a2b = queue.Queue()
    b2a = queue.Queue()
    return (Mocket(a2b, b2a), Mocket(b2a, a2b))


# And these are some helpers for executing a full handshake on two
# separate threads, and collecting the results.

def run_handshake(client_cb, server_cb):
    """Run the given client/server callbacks in parallel, returning sent data.
    
    This function spawns two background threads on which to run the given
    callbacks in parallel. Each will be passed an instance of `TLSConnection`
    through which it can communicate with the other.

    Once both callbacks complete, this function will return a tuple (c, s) of
    the data sent by the client, and by the server. If either callback throws
    an error it will be propagated into the main thread.
    """
    c, s = mocketpair()
    client = TLSConnection(c)
    server = TLSConnection(s)
    errors = []

    def run_client():
        try:
            client_cb(client)
        except Exception as err:
            errors.append(err)

    def run_server():
        try:
            server_cb(server)
        except Exception as err:
            errors.append(err)

    tc = threading.Thread(target=run_client)
    ts = threading.Thread(target=run_server)
    tc.start()
    ts.start()
    tc.join()
    ts.join()
    if errors:
        raise errors[0]
    assert len(MOCKED_URANDOM_CALLS) == 0, 'unused mock urandom call'
    return (c.sent_data, s.sent_data)


# OK, we're ready to do some handshakes!

# For the first scenario, we do a minimal PSK-only handshake
# that should exactly match the bytes generated by the JS code.

PSK_ID = b'testkey'
PSK = b'aabbccddeeff'
SESSION_ID = b'00000000000000000000000000000001'
CLIENT_RANDOM = b'01010101010101010101010101010101'
SERVER_RANDOM = b'02020202020202020202020202020202'
CLIENT_RAW_APP_DATA = b'hello world'
CLIENT_RAW_APP_DATA_2 = b'how are you?'
SERVER_RAW_APP_DATA=b'hello world'
SERVER_RAW_APP_DATA_2=b'fine thanks and you?'

printComment("Data that comes from the outside world in one way or another")
printTestVectorStr("PSK_ID", PSK_ID)
printTestVectorStr("PSK", PSK)
printTestVectorStr("SESSION_ID", SESSION_ID)
printTestVectorStr("CLIENT_RANDOM", CLIENT_RANDOM)
printTestVectorStr("SERVER_RANDOM", SERVER_RANDOM)
printTestVectorStr("CLIENT_RAW_APP_DATA", CLIENT_RAW_APP_DATA)
printTestVectorStr("SERVER_RAW_APP_DATA", SERVER_RAW_APP_DATA)
printTestVectorStr("CLIENT_RAW_APP_DATA_2", CLIENT_RAW_APP_DATA_2)
printTestVectorStr("SERVER_RAW_APP_DATA_2", SERVER_RAW_APP_DATA_2)

print("\n")

minimalSettings = HandshakeSettings()
# Flag that we only speak TLS1.3, not earlier versions.
minimalSettings.minVersion = (3, 4)
minimalSettings.maxVersion = (3, 4)
minimalSettings.versions = [(3, 4)]
# Use our single supported ciphersuite,
# and no DHE or certificates.
minimalSettings.cipherNames = ['aes128gcm']
minimalSettings.keyExchangeNames = []
minimalSettings.keyShares = []
minimalSettings.eccCurves = []
minimalSettings.dhGroups = []
minimalSettings.rsaSchemes = []
# Disable some extensions that are on by default in tlslite-ng.
minimalSettings.useEncryptThenMAC = False
minimalSettings.useExtendedMasterSecret = False
minimalSettings.use_heartbeat_extension = False
minimalSettings.record_size_limit = None
# Configure the single pre-established PSK.
minimalSettings.pskConfigs = [(PSK_ID, PSK, 'sha256')]
minimalSettings.psk_modes = ['psk_ke']

MOCKED_URANDOM_CALLS.extend((
    SESSION_ID,
    CLIENT_RANDOM,
    SERVER_RANDOM,
))

def run_client_minimal(client):
    client.handshakeClientCert(settings=minimalSettings)
    client.send(CLIENT_RAW_APP_DATA)
    assert client.recv(1024) == SERVER_RAW_APP_DATA
    client.send(CLIENT_RAW_APP_DATA_2)
    assert client.recv(1024) == SERVER_RAW_APP_DATA_2
    client.close()

def run_server_minimal(server):
    server.handshakeServer(settings=minimalSettings)
    assert server.recv(1024) == CLIENT_RAW_APP_DATA
    server.send(SERVER_RAW_APP_DATA)
    assert server.recv(1024) == CLIENT_RAW_APP_DATA_2
    server.send(SERVER_RAW_APP_DATA_2)
    server.close()

(c_sent, s_sent) = run_handshake(run_client_minimal, run_server_minimal)

printComment("Trace from a minimal client talking to a minimal server")
# The initial ClientHello record is sent with version 0x0301 for b/w compat,
# but we don't want or need that for our implementation. Fix it to 0x0303.
assert c_sent[0][:3] == b'\x16\x03\x01'
c_sent[0][2] = 0x03
printTestVectorBytes("CLIENT_HELLO", c_sent[0])
# The change-cipher-spec and client-finished are emitted in a single send.
printTestVectorBytes("CLIENT_CHANGE_CIPHER_SPEC", c_sent[1][:6])
printTestVectorBytes("CLIENT_FINISHED", c_sent[1][6:])
printTestVectorBytes("CLIENT_APP_DATA", c_sent[2])
printTestVectorBytes("CLIENT_APP_DATA_2", c_sent[3])
printTestVectorBytes("CLIENT_CLOSE", c_sent[4])
assert len(c_sent) == 5

# The server-hello has a change-cipher spec appended to it.
printTestVectorBytes("SERVER_HELLO", s_sent[0][:-6])
printTestVectorBytes("SERVER_CHANGE_CIPHER_SPEC", s_sent[0][-6:])
printTestVectorBytes("SERVER_ENCRYPTED_EXTENSIONS_AND_FINISHED", s_sent[1])
printTestVectorBytes("SERVER_APP_DATA", s_sent[2])
printTestVectorBytes("SERVER_APP_DATA_2", s_sent[3])
printTestVectorBytes("SERVER_CLOSE", s_sent[4])
assert len(s_sent) == 5

print("\n")

# For some additional tests of key generation, we use tlslite-ng's low-level
# derivation functions to run the TLS1.3 keyschedule.  It doesn't seem to expose
# a nice API that encapsulates these calculations directly.

printComment("Testcases for key derivation")
prf = "sha256"
transcript = HandshakeHashes()
earlySecret = secureHMAC(bytearray(32), PSK, prf)
printTestVectorBytes(
    "KEYS_EXT_BINDER",
    derive_secret(earlySecret, b"ext binder", None, prf)
)

handshakeSecret = secureHMAC(
    derive_secret(earlySecret, b"derived", None, prf),
    bytearray(32),  # No ECDHE, so use zeros.
    prf
)
printTestVectorStr("KEYS_PLAINTEXT_TRANSCRIPT", b'fake plaintext transcript')
transcript.update(b'fake plaintext transcript')
printTestVectorBytes(
    "KEYS_CLIENT_HANDSHAKE_TRAFFIC_SECRET",
    derive_secret(handshakeSecret, b"c hs traffic", transcript, prf)
)
printTestVectorBytes(
    "KEYS_SERVER_HANDSHAKE_TRAFFIC_SECRET",
    derive_secret(handshakeSecret, b"s hs traffic", transcript, prf)
)

masterSecret = secureHMAC(
    derive_secret(handshakeSecret, b"derived", None, prf),
    bytearray(32),
    prf
)
printTestVectorStr("KEYS_ENCRYPTED_TRANSCRIPT", b'fake encrypted transcript')
transcript.update(b'fake encrypted transcript')
printTestVectorBytes(
    "KEYS_CLIENT_APPLICATION_TRAFFIC_SECRET_0",
    derive_secret(masterSecret, b"c ap traffic", transcript, prf)
)
printTestVectorBytes(
    "KEYS_SERVER_APPLICATION_TRAFFIC_SECRET_0",
    derive_secret(masterSecret, b"s ap traffic", transcript, prf)
)

print("\n")

# Next, we use a more featureful ClientHello, so that we can test
# handling of unsupported ClientHello extension fields etc.
# This simulates some future version of the Client with lots more features
# talking to a current version of the Server that implements the
# single PSK mode.

fullSettings = HandshakeSettings()
# Pretend to speak some future version of TLS, to test negotiation.
fullSettings.minVersion = (3, 4)
fullSettings.maxVersion = (3, 4)
fullSettings.versions = [(3, 4), (3, 5)]
# Offer several PSKs
fullSettings.pskConfigs = [
    (b'a dummy key', b'111222333444555', 'sha384'),
    (PSK_ID, PSK, 'sha256'),
    (b'another dummy key', b'qwertyqwertyqwerty', 'sha384'),
]
fullSettings.psk_modes = ['psk_ke', 'psk_dhe_ke']
# Leave everything else set to defaults, so it will include ECDHE keyshares,
# other ciphersuites, etc.

MOCKED_URANDOM_CALLS.extend((
    SESSION_ID,
    orig_urandom(32), # Client keyshare generation.
    orig_urandom(32), # Use actual random values here because they should be ignored.
    CLIENT_RANDOM,
    orig_urandom(32), # Server keyshare generation.
    SERVER_RANDOM,
))

def run_client_full(client):
    client.handshakeClientCert(settings=fullSettings)
    client.send(CLIENT_RAW_APP_DATA)
    assert client.recv(1024) == SERVER_RAW_APP_DATA
    client.send(CLIENT_RAW_APP_DATA_2)
    assert client.recv(1024) == SERVER_RAW_APP_DATA_2
    client.close()

def run_server_full(server):
    server.handshakeServer(settings=fullSettings)
    assert server.recv(1024) == CLIENT_RAW_APP_DATA
    server.send(SERVER_RAW_APP_DATA)
    assert server.recv(1024) == CLIENT_RAW_APP_DATA_2
    server.send(SERVER_RAW_APP_DATA_2)
    server.close()

(c_sent, s_sent) = run_handshake(run_client_full, run_server_full)

# Unfortunately, I've been unable to get tlslite-ng to negotiate itself down
# to using PSK_KE mode when the server doesn't support any ECDHE groups.
# For now we just want the ClientHello to feed it into our tests.
printComment("ClientHello from a full-featured client")
assert c_sent[0][:3] == b'\x16\x03\x01'
c_sent[0][2] = 0x03
printTestVectorBytes("EXTENDED_CLIENT_HELLO", c_sent[0])

# Finally, the JS file footer.

print("""
};

/* eslint-enable sorting/sort-object-props */
""")
